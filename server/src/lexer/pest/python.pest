// Copyright (C) 2023 Bryan A. Jones.
//
// This file is part of the CodeChat Editor. The CodeChat Editor is free
// software: you can redistribute it and/or modify it under the terms of the GNU
// General Public License as published by the Free Software Foundation, either
// version 3 of the License, or (at your option) any later version.
//
// The CodeChat Editor is distributed in the hope that it will be useful, but
// WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
// details.
//
// You should have received a copy of the GNU General Public License along with
// the CodeChat Editor. If not, see
// [http://www.gnu.org/licenses](http://www.gnu.org/licenses).
//
// # `python.pest` - Pest parser definition for Python
file      =  { SOI ~ (doc_block | code_block)* ~ EOI}
doc_block = _{ inline_comment }

// Per the
// [Python standard, section string.whitespace](https://docs.python.org/3/library/string.html#string.whitespace),
// "white-space consists of: (space, horizontal tab, linefeed, return, vertical tab, and
// form-feed)." Omit newlines, since the rest of this parser uses these.
vertical_tab = { "\x0B" }
form_feed    = { "\x0C" }
white_space  = { (" " | "\t" | vertical_tab | form_feed)* }

// The
// [Python standard, PEP 8 Style guide](https://peps.python.org/pep-0008/#inline-comments),
// defines inline comments.
//
// ## Inline comments
//
// Use this approach to match a group of inline comments with the same
// whitespace indentation.
inline_comment      =  { inline_comment_init ~ inline_comment_cont* ~ DROP ~ DROP }
inline_comment_init = _{ PUSH(white_space) ~ PUSH(inline_comment_delims) ~ inline_comment_body }
// Match on the same whitespace (second from the top of stack) and then the same
// comment delimiter (at the top of stack) for continued comments.
inline_comment_cont = _{ PEEK[-1..-2] ~ PEEK ~ inline_comment_body }
// Other languages support more inline comment delimiters; even if they're not
// used, they must be defined here.
inline_comment_delims  = _{ inline_comment_delim_0 }
inline_comment_delim_0 =  { "#" }
inline_comment_delim_1 =  { "unused" }
inline_comment_delim_2 =  { "unused" }
// This accepts an inline comment containing a space then some contents, or an
// inline comment immediately followed by a newline.
inline_comment_body     = { (" " ~ inline_comment_contents) | newline_eoi }
inline_comment_contents = { "#" ~ NEWLINE | not_newline* ~ newline_eoi }
// Per the
// [Python Standard, section 2.1.1](https://docs.python.org/3/reference/lexical_analysis.html#logical-lines),
// The end of a logical line is represented by the token NEWLINE.
// A line ending in a backslash cannot carry a comment.
// A backslash does not continue a comment.
// A backslash does not continue a token except for string literals.
newline_eoi = _{ NEWLINE | EOI }
not_newline = _{ !NEWLINE ~ ANY }

// ## Block comments
//
// Block comments never combine.
block_comment = {
    white_space ~ block_comment_opening_delims ~ block_comment_pre ~ contents ~ " "? ~ "*/" ~ white_space ~ block_comment_ending
}
// Support multiple opening delimiters for other languages; assume the closing
// delimiter is always the same.
block_comment_opening_delims  = _{ block_comment_opening_delim_0 }
block_comment_opening_delim_0 =  { "unused" }
block_comment_opening_delim_1 =  { "unused" }
block_comment_opening_delim_2 =  { "unused" }
block_comment_closing_delim   = _{ "unused" }
block_comment_pre             =  { " " | newline_eoi }
// TODO: rewrite for languages that supported nested block comments.
//
// If there's a space immediately before the block closing delimiter, don't
// capture it, so that this space can be discarded in the `block_comment` token.
contents = { (!(" "? ~ block_comment_closing_delim) ~ ANY)* }
// Use this so that the ending (usually a newline) gets captured in a token.
block_comment_ending = { newline_eoi }

// ## Code blocks
code_block = { code_line+ }
multi_line_string_delim_0   = _{"'''" | "\"\"\""}
multi_line_string_contents  = _{!(multi_line_string_delim_0) ~ ANY}
// If there is text or characters within the triple quoted string, it will be regarded as a code block.
multi_line_string           =  _{ (multi_line_string_delim_0 ~ (multi_line_string_contents)* ~ multi_line_string_delim_0) }
// Account for the continuation character of concatenating strings on a new line
continuation_character      =  _{ "\\" ~ NEWLINE }
single_double_quoted_string_delim_0   = _{"'" | "\""}
single_double_quoted_string_contents  =  _{!continuation_character ~ !single_double_quoted_string_delim_0 ~ ANY}
single_double_quoted_string           = _{single_double_quoted_string_delim_0 ~ (single_double_quoted_string_contents)* ~ (NEWLINE | single_double_quoted_string)}
// ## Code line
code_line                   = _{ ((!doc_block ~ multi_line_string | single_double_quoted_string | not_newline)+ ~ NEWLINE) | !(inline_comment_delim_0) ~ ("'''" | "\"\"\"") | (!doc_block ~ not_newline+ ~ EOI) }
// ## Dedenter
dedenter = { "not used" }
