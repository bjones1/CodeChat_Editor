<details>
    <summary>License</summary>
    <p>Copyright (C) 2022 Bryan A. Jones.</p>
    <p>This file is part of the CodeChat Editor.</p>
    <p>The CodeChat Editor is free software: you can redistribute it and/or
        modify it under the terms of the GNU General Public License as
        published by the Free Software Foundation, either version 3 of the
        License, or (at your option) any later version.</p>
    <p>The CodeChat Editor is distributed in the hope that it will be useful,
        but WITHOUT ANY WARRANTY; without even the implied warranty of
        MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
        General Public License for more details.</p>
    <p>You should have received a copy of the GNU General Public License along
        with the CodeChat Editor. If not, see <a
            href="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</a>.
    </p>
</details>
<h1>Implementation</h1>
<h2><a id="an-implementation"></a>1.4 Architecture</h2>
<h3>Doc block markup</h3>
<ul>
    <li>For any markup, must either have:
        <ul>
            <li>Round-trip capable conversion: from x to HTML (load), then from
                HTML back to x (save).</li>
            <li>A GUI editor that works on this markup language. I don't know
                of any (except for HTML).</li>
        </ul>
    </li>
    <li>HTML is simple to implement (already done). However, it's less
        readable.</li>
    <li>If we make Pandoc a dependency, then supporting a wide variety of
        markup languages is easy. However, any candidate language must be able
        to preserve arbitrary HTML, which may be problematic.</li>
    <li>Markdown is very well known, due to GitHub's use of it, and is more
        readable (IMHO). It seems like a possible candidate -- anything that
        can't be translated from HTML from Markdown can simply be left as HTML,
        since Markdown allows HTML as a part of its syntax. Markdown has a
        JavaScript implementation for markdown to HTML. Pandoc can translate
        HTML back to Markdown, but this requires installation of another
        program and adds to the server-side complexity. The <a
            href="https://github.com/commonmark/commonmark.js/blob/master/lib/render/html.js">code</a>
        that CommonMark uses to translate from their AST into HTML looks pretty
        straightforward, so the inverse shouldn't be too hard.</li>
    <li><span style="background-color: rgb(251, 238, 184);">Markdown-to-HTML
            conversion (for doc-blocks only):</span>
        <ul>
            <li><span style="background-color: rgb(251, 238, 184);">TODO:
                    <br></span>
                <ul>
                    <li><span
                            style="background-color: rgb(251, 238, 184);">import
                            pulldown-cmark library within
                            webserver.rs&nbsp;</span></li>
                    <li><span
                            style="background-color: rgb(251, 238, 184);">insert
                            conversion [function?] in "Save Endpoint"
                            section</span>
                        <ul>
                            <li
                                style="color: rgb(35, 111, 161); font-weight: bold;">
                                <strong><span
                                        style="background-color: rgb(251, 238, 184); color: rgb(35, 111, 161);">Immediately
                                        after doc and code blocks have been
                                        parsed/split?</span></strong></li>
                            <li><span
                                    style="background-color: rgb(251, 238, 184);">check
                                    if already HTML. if so, move on without
                                    changes. Skip code blocks</span></li>
                            <li
                                style="font-weight: bold; color: rgb(35, 111, 161);">
                                <span
                                    style="color: rgb(35, 111, 161);"><strong><span
                                            style="background-color: rgb(251, 238, 184);">Should
                                            this be implemented within the
                                            parsing
                                            section?</span></strong></span>
                            </li>
                            <li
                                style="font-weight: bold; color: rgb(35, 111, 161);">
                                <span
                                    style="color: rgb(35, 111, 161);"><strong><span
                                            style="background-color: rgb(251, 238, 184);">Should
                                            we give user the option to convert
                                            to HTML, or do it
                                            automatically?</span></strong></span>
                            </li>
                        </ul>
                    </li>
                </ul>
            </li>
            <li style="font-weight: bold; color: rgb(35, 111, 161);"><span
                    style="color: rgb(0, 0, 0);"><strong><span
                            style="background-color: rgb(251, 238, 184);">Where
                            to implement pulldown-cmark
                            function?</span></strong></span>
                <ul>
                    <li style="color: rgb(35, 111, 161);"><span
                            style="color: rgb(0, 0, 0);"><span
                                style="background-color: rgb(251, 238, 184);">We've
                                marked the potential location in
                                Cargo.toml.</span></span></li>
                    <li style="color: rgb(35, 111, 161);"><span
                            style="color: rgb(0, 0, 0);"><span
                                style="background-color: rgb(251, 238, 184);">TODO:
                                Add descriptive paragraph of markdown-&gt;html
                                purpose/theory</span></span></li>
                </ul>
            </li>
        </ul>
    </li>
</ul>
<h3><span style="color: rgb(0, 0, 0);">Markdown to HTML Conversion
        Implementation</span></h3>
<p><span style="color: rgb(0, 0, 0);">Currently, CodeChat only loads and saves
        doc blocks in HTML format. This can make a CodeChat-edited script hard
        to read when opened in another IDE, due to the HTML markup language
        being syntax heavy. To make the output more readable, we propose having
        CodeChat's main input/output doc block language to be Markdown rather
        than HTML. Markdown is a markup language with lighter syntax that is
        more intuitive to read. </span></p>
<p><span style="color: rgb(0, 0, 0);">Keeping HTML as the markup language may
        make the editor harder to use, which could scare away potential users
        of the software. We want to mitigate this from occurring by
        implementing Markdown in place of HTML.</span></p>
<p><span style="color: rgb(0, 0, 0);">This implementation will transform files
        as normal, but instead of the code blocks undergoing the
        pipeline:</span></p>
<p><span style="color: rgb(0, 0, 0);">Load File --&gt; Convert to HTML --&gt;
        Write Stuff --&gt; Convert to HTML --&gt; Save File,</span></p>
<p><span style="color: rgb(0, 0, 0);">we will have</span></p>
<p>Load File --&gt; Convert to Markdown --&gt; Convert to HTML --&gt; Write
    Stuff --&gt; Convert to HTML --&gt; Convert to Markdown --&gt; Save File.
</p>
<p>First, we will be focusing on the first half of the pipeline, converting
    Markdown to HTML. We can simply convert Markdown to HTML using the
    pulldown-cmark crate, which should be implemented right after the doc and
    code blocks have been parsed.&nbsp;</p>
<p>TODO: Import the <a
        href="https://docs.rs/pulldown-cmark/latest/pulldown_cmark/">pulldown-cmark</a>
    crate within webserver.rs in the Load Endpoint section, immediately after
    the doc and code blocks have been parsed. Code blocks will be
    skipped.&nbsp;</p>
<p>Once completed, doc blocks written in Markdown can be converted by the
    editor into HTML for further use. Then, the second half of the pipeline can
    be implemented.</p>
<h3>Lexing</h3>
<p>TODO: describe the lexer implementation. Link to the walkthrough, discuss
    the language specification, etc.</p>
<h3>Client/server partitioning</h3>
<p>Code blocks consist of standard HTML augmented with custom HTML elements
    which provide authoring support. Some of these elements depend only on
    information in the current page. For example, a GraphViz graph tag
    transforms the graph provided in its tag into an SVG; it doesn't&nbsp; need
    information from other files. Other elements, such as a cross-reference
    tag, depend on information from other pages (in this case, the page
    containing the referenced item). The client lacks the ability to access
    other files, while the server has direct access to these files. Therefore,
    the overall strategy is:</p>
<ul>
    <li>On page load, the server transforms custom tags which depend on
        information from other pages into tags which include this information.
        For example, a cross-reference tag might be transformed into a
        hyperlink whose link text comes from the cross-reference on another
        page.</li>
    <li>The client them defines a set of <a
            href="https://developer.mozilla.org/en-US/docs/Web/Web_Components">Web
            Components</a> which implement custom tags which only need local
        information. For example, a GraphViz custom tag renders graphs based on
        a description of the graph inside the tag.</li>
    <li>The client sends edits (including creating a tag or deleting it) to
        tags which depend on server-side information to the server for
        transformation.</li>
    <li>On save, the client sends its text back to the server, which
        de-transforms custom tags which depend on information from other pages.
    </li>
</ul>
<p>Page processing pipeline</p>
<p>On load:</p>
<ul>
    <li>Server:
        <ul>
            <li>Run pre-parse hooks: they receive source code, file metadata.
                Examples: code formatters. Skip if cache is up to date.</li>
            <li>Parse the file into code and doc blocks.</li>
            <li>Run post-parse hooks: they receive an array of code and doc
                blocks. I can't think of any sort of processing to do here,
                though.</li>
            <li>Update the cache for the current file only if the current
                file's cache is stale. To do this, walk the DOM of each doc
                block. The hook specifies which tags it wants, and the tree
                walked calls the hook when it encounters these.</li>
            <li>Update tags whose content depend on data from other files.
                Hooks work the same as the cache updates, but have a different
                role. They're always run, while the cache update is skipped
                when the cache is current.</li>
            <li>Determine next/prev/up hyperlinks based on this file's location
                in the TOC.</li>
        </ul>
    </li>
    <li>Client:
        <ul>
            <li>Any edits to items with a specific class are sent to the server
                for processing/rendering.</li>
        </ul>
    </li>
</ul>
<p>On save: the same process in reverse.</p>
<h3>Table of contents</h3>
<ul>
    <li>While the TOC file must be placed in the root of the project, it will
        be served alongside pages served from subdirectories. What's the best
        approach? An iframe; otherwise, need to rewrite all URLs (images,
        links, etc.) which sounds hard.</li>
    <li>The TOC is just HTML. Numbered sections are expressed as nested ordered
        lists, with links to each section inside these lists.</li>
    <li>All numbering is stored internally as a number, instead of the
        corresponding marker (I, II, III, etc.). This allows styles to
        customize numbering easily. In addition, while&nbsp;JavaScript can find
        the index of each item in an ordered list, but it can't get the actual
        marker used (Roman numbers, bullets, or things generated by <a
            href="https://developer.mozilla.org/en-US/docs/Web/CSS/list-style-type">list-style-type</a>).
        There's a CSS&nbsp;<a
            href="https://developer.mozilla.org/en-US/docs/Web/CSS/::marker">::marker</a>
        selector, but not way to get the rendered text. Even <a
            href="https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/innerText">innerText</a>
        doesn't include the marker in the resulting text.</li>
    <li>&nbsp;Old notes:
        <ul>
            <li>Then,&nbsp;<code>document.querySelector('[href="https://example.com"]')</code>
                finds the first instance of the current page's link, which
                takes care of scrolling the TOC.</li>
            <li>Given the a element in the TOC, looking through its parents
                provides the section number. Given an array of section numbers,
                use CSS to style all the headings. One approach, which makes it
                easy for a style sheet to include or exclude section numbers,
                by making them CSS variables:<br>
                <p><code>:root {</code><br><code>&nbsp;
                        --section-counter-reset: s1 4 s2
                        5;</code><br><code>&nbsp;
                        --section-counter-content:
                        counter(s1,
                        numeric) '-' counter(s2,
                        numeric);</code><br><code>}</code></p>
                <p><code>h1::before
                        {</code><br><code>&nbsp;
                        counter-reset:
                        var(--section-counter-reset);</code><br><code>&nbsp;
                        content:
                        var(--section-counter-content);</code><br><code>}</code>
                </p>
            </li>
            <li>Plan:
                <ol>
                    <li>Implement a project finder -- starting at the current
                        directory, ascend to the root looking for the project
                        file. If so, return a web page which includes the TOC
                        as a sidebar plus some navigation (prev/next/up)
                        placeholders. For prev/next, use this:<br><code>t =
                            document.createTreeWalker(document.body,
                            NodeFilter.SHOW_ELEMENT,
                            {&nbsp;</code><br><code>&nbsp;
                            acceptNode(node)
                            {</code><br><code>&nbsp; &nbsp; return
                            node.nodeName === "A" ?
                            NodeFilter.FILTER_ACCEPT :
                            NodeFilter.FILTER_SKIP;</code><br><code>&nbsp;
                            }&nbsp;</code><br><code>});</code><br><code>t.currentNode
                            = &lt;link corresponding to current
                            page&gt;</code><br><code>next =
                            t.nextNode();</code></li>
                    <li>Implement TOC scroll (on the client -- easy there).
                        This means finding the first hyperlink to the current
                        page. Given that, it's fairly easy to determine
                        prev/next/up and section numbers. Implement all these.
                    </li>
                </ol>
            </li>
        </ul>
    </li>
</ul>
<h3><a id="combined-code-document-editor"></a>Combined code/document editor
</h3>
<ul>
    <li>Need to find some way to allow syntax highlighting, code folding, etc.
        to work across code blocks. Need to have just the code blocks, along
        with a way to map these code back to the resulting document.</li>
</ul>
<h3>Cached state</h3>
<p>When hydrating a page (transforming all custom tags into standard HTML) on
    the server, all needed hydration data should be stored in the cache.</p>
<h4>Data and format</h4>
<ul>
    <li>For each file (including anything linkable -- images, videos, etc.),
        stored as the relative path from the project's root directory to that
        file:
        <ul>
            <li>A time/date stamp to determine if this cached data is stale or
                not.</li>
            <li>The global TOC numbering.</li>
            <li>A nested list of headings, represented by their anchor. For
                headings without an anchor, assign one.</li>
        </ul>
    </li>
    <li>For each anchor:
        <ul>
            <li>The page it's in, as a path to the file containing this page.
            </li>
            <li>The outer HTML of the item it refers to (self/sibling/etc.),
                for use with references.</li>
            <li>Its numbering within the current page, also for use with
                references.&nbsp;</li>
            <li>A list of referring links, represented by their anchor. For
                links without an anchor, assign one.</li>
        </ul>
    </li>
</ul>
<h4>Editing and cached state</h4>
<p>Edits to the document of any cached items cause the browser to push this
    edit to the server; the server then propagates the edits to open windows
    and updates its state. If a modified file is closed without saving it
    (meaning the cached state for this file is now invalid), then all that
    cache state must be flushed. To flush, simply set the date/time stamp of
    that file to something old/invalid.</p>
<h3>TOC custom tag</h3>
<p>Options:</p>
<ul>
    <li>Path to linked file</li>
    <li>Depth of numbering</li>
</ul>
<h4>Example</h4>
<div class="CodeChat-toc mceNonEditable"
    data-codechat-path="static/css/CodeChatEditor.css" data-codechat-depth="">
    <p>asdf</p>
</div>
<h3>Numbering</h3>
<p>On a page, the local TOC numbering comes only from heading tags. The CSS
    (which would adding numbering to selected headings) must be kept in sync
    with the code which infers the numbering. A simple value (4, meaning h1-h4
    are numbered) is all the code needs. How to do this?</p>
<p>On the TOC, numbering may come from both heading tags and ordered lists,
    again based on the CSS. Numbered headings should be included in the
    numbering, followed by ordered list numbering.&nbsp;</p>
<h3>Settings</h3>
<p>The settings should be configurable from a nice GUI. I like the VSCode idea
    -- make it easy to add more config values. Settings should also be
    available for plug-ins. Store the config values in a bare JSON file;
    provide a web-based GUI with descriptions of each setting.</p>
<ul>
    <li>Files/directories to process/ignore</li>
    <li>Header/footer info (name, version, copyright, etc.)</li>
    <li>The programming language, markup language, and spellchecker language
        for each source file.</li>
    <li>Text wrap width when saving.</li>
    <li>Visual styling (theme/style sheets, color, fonts, size of TOC sidebar,
        location of sidebar, etc.).</li>
    <li>HTML <code>&lt;head&gt;</code> modifications: CSS/JS to add to all
        pages/a set of pages.</li>
    <li>Depth of headings to include in the page-local TOC.</li>
    <li>Auto-reload if modified externally or not</li>
    <li>Tabs vs spaces; newline type</li>
    <li>Substitutions</li>
</ul>
<h3><a id="core-developmnt-priorities"></a>Core development priorities</h3>
<ol>
    <li>IDE integration</li>
    <li>Editor functionality</li>
</ol>
<h3><a id="next-steps"></a>Next steps</h3>
<ol>
    <li>Implement Markdown. Use <a
            href="https://docs.rs/pulldown-cmark/latest/pulldown_cmark/">pulldown-cmark</a>
        to transform Markdown to HTML. <a
            href="https://github.com/mixmark-io/turndown">Turndown</a> has all
        the features we want, but is written in JavaScript. <a
            href="https://crates.io/crates/html2md">html2md</a> is written in
        Rust, but doesn't support CommonMark or have the feature set we need.
        Another option is to use <a href="https://pandoc.org">Pandoc</a>.</li>
    <li>Refactor the webserver to pull out the processing step (converting
        source code to code/doc blocks). Run this in a separate thread -- see
        the <a
            href="https://docs.rs/tokio/latest/tokio/#cpu-bound-tasks-and-blocking-code">Tokio
            docs</a> on how to await a task running in another thread.</li>
    <li>Implement caching for all anchors/headings.</li>
    <li>Implement author support: TOC, auto-titled links.</li>
    <li>Implement a good GUI for inserting hyperlinks.</li>
    <li>Better support for template literals.</li>
    <li>Decide how to handle nested block comments.</li>
    <li>Define the architecture for IDE extensions/plug-ins. Goal: minimize
        extension/plug-in complexity.</li>
    <li>Define desired UI behavior. Priority: auto-reload; dirty document
        detection; auto-backup.</li>
    <li>Implement Markdown support.</li>
    <li>Propose visual styling, dark mode, etc.</li>
</ol>
<h3>To do</h3>
<ol>
    <li>Improve accessibility -- use a <code>&lt;main&gt;</code> tag,
        <code>&lt;nav&gt;</code> tags, etc.</li>
    <li>Open the TOC as a single-file edit? If not, at least hide the sidebar,
        since that's redundant.</li>
</ol>
<h3>Open questions</h3>
<ul>
    <li>I'd like to be able to wrap a heading and associated content in a
        <code>&lt;section&gt;</code> tag. This is hard to do -- if a heading
        appears in the middle of an indented comment, then need special
        processing (close the section, then the indent, then restart a new
        indent and section). In addition, it requires that code is nested
        inside doc blocks, which is tricky. However, I would like to do this.
    </li>
    <li>How to handle images/videos/PDFs/etc. when file are moved? Currently,
        we expect the user to move them as well. There's not an easy way to tag
        them with an unique ID, then refer to them using that ID than I can
        think of.</li>
    <li>Config file format: I really like and prefer Python's strictyaml.
        Basically, I want something that includes type validation and allows
        comments within the config file. Perhaps JSON with a pre-parse step to
        discard comments then <a href="https://jsontypedef.com/">JSON
            Typedef</a>? Possibly, vlang can do this somewhat, since it wants
        to decode JSON into a V struct.)</li>
</ul>
<h2>1.5 Organization</h2>
<h3>Client</h3>
<p>As shown in the figure below, the CodeChat Editor client starts with
    <code>client/webpack/package.json</code>, which tells <a
        href="https://en.wikipedia.org/wiki/Npm_(software)">NPM</a> which
    JavaScript libraries are used in this project. Running <code>npm
        update</code>&nbsp;copies these libraries and all their dependencies to
    the <code>client/webpack/node_modules</code> directory. The CodeChat Editor
    client source code (see <a
        href="../client/webpack/CodeChat-editor.mts">CodeChat-editor.mts</a>)
    imports these libraries.</p>
<p>Next, <a href="https://esbuild.github.io/">esbuild</a> analyzes the CodeChat
    Editor client based&nbsp;by transforming any <a
        href="https://www.typescriptlang.org/">TypeScript</a> into JavaScript
    then packaging all dependencies (JavaScript, CSS, images, etc.) into a
    smaller set of files. At a user's request, the CodeChat Editor server
    generates HTML which creates an editor around the user-requested file. This
    HTML loads the packaged dependencies to create the CodeChat Editor webpage.
</p>
<graphviz-graph graph="digraph {
    JS_lib [label = &quot;JavaScript libraries&quot;];
    &quot;package.json&quot; -&gt; JS_lib [label = &quot;npm update&quot;];
    JS_lib -&gt; esbuild;
    CCE_source [label = &quot;CodeChat Editor\nclient-side source&quot;];
    JS_lib -&gt; CCE_source [label = &quot;imports&quot;];
    CCE_source -&gt; esbuild;
    esbuild -&gt; &quot;Packaged JavaScript&quot;;
    CCE_webpage [label = &quot;CodeChat Editor\nwebpage&quot;];
    &quot;Packaged JavaScript&quot; -&gt; CCE_webpage;
    server_HTML [label = &quot;CodeChat Editor\nserver-generated\nHTML&quot;];
    server_HTML -&gt; CCE_webpage;
}"></graphviz-graph>
<p>However, esbuild's code splitting doesn't work with dynamic imports -- the
    splitter always picks Node-style default imports, while the Ace editor
    expects Babel-style imports.</p>
<p>TODO: GUIs using TinyMCE. See the <a
        href="https://www.tiny.cloud/docs/tinymce/6/dialog-components/#panel-components">how-to
        guide</a>.</p>
<h3>System architecture</h3>
<graphviz-graph graph="digraph {
    bgcolor = transparent;
    compound = true;
    node [shape = box];
    subgraph cluster_text_editor {
        label = &quot;Text editor/IDE&quot;;
        source_code [label = &quot;Source\ncode&quot;, style = dashed];
        CodeChat_plugin [label = &quot;CodeChat\nEditor plugin&quot;];
    }

    subgraph cluster_server {
        label = &lt;CodeChat Editor Server&gt;;
        websocket_server [label = &quot;Websocket\nserver&quot;];
        web_server [label = &quot;Web\nserver&quot;];
    }

    subgraph cluster_client {
        label = &quot;CodeChat Editor Client&quot;;
        rendered_code [label = &quot;Rendered code&quot;, style = dashed];
        JavaScript;
    }

    CodeChat_plugin -&gt; websocket_server [dir = both];
    websocket_server -&gt; JavaScript [dir = both];
    web_server -&gt; JavaScript [label = &quot;HTTP&quot;, dir = both, lhead = cluster_client];
}"></graphviz-graph>
<p>Note: this second diagram will be the same as the first until <a
        href="https://github.com/prantlf/graphviz-webcomponent/pull/4">this
        fix</a> is merged.</p>
<h2>Code style</h2>
<p>JavaScript functions are a <a
        href="https://dmitripavlutin.com/differences-between-arrow-and-regular-functions/">disaster</a>.
    Therefore, we use only arrow functions for this codebase.</p>
<p>Other than that, follow the <a
        href="https://developer.mozilla.org/en-US/docs/MDN/Writing_guidelines/Writing_style_guide/Code_style_guide/JavaScript">MDN
        style guide</a>.</p>
